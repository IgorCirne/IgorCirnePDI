:toc: left
:toclevels: 2
:toc-title: Sum√°rio
:!figure-caption:

= Processamento Digital de Imagens
Igor Cirne Borges de Oliveira

:icons: font
:summary:

toc::[]
== Introdu√ß√£o

Esta √© uma p√°gina dedicada aos projetos e atividades de PDI, criada com AsciiDoc e hospedada no GitHub Pages.

== Lista 1

=== Cap√≠tulo 2. Manipulando pixels em uma imagem
Com base no programa https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/pixels.cpp[pixels.cpp] , foi gerado o programa https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/regions.cpp[regions.cpp] que √© capaz de,
ao entrar com as coordenadas (x, y) de dois pontos P1 e P2, deixar a regi√£o entre eles com cores em negativo.

Para o exerc√≠cio, a imagem abaixo foi dada como entrada no c√≥digo:

.Figura 1: biel.png
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/biel.png]
image::exercicio_2/biel.png[]

E ap√≥s compilar o programa com o https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/CMakeLists.txt[CMakeLists.txt] adequado, foram obtido os resultados abaixo:


P1 = [100, 50]
P2 = [200, 200]

.Figura 2: biel-2.png
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/biel-2.png]
image::exercicio_2/biel-2.png[]


P1 = [50, 50]
P2 = [100, 150]

.Figura 3: biel-3.png
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/biel-3.png]
image::exercicio_2/biel-3.png[]


Para a segunda parte do exerc√≠cio, a de troca de regi√µes, foi feito o c√≥digo de https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/trocaregioes.cpp[trocaregioes.cpp] e foi preciso modificar um pouco o arquivo anterior para este https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/CMakeLists2.txt[CMakeLists.txt], novamente, com a imagem original do Biel.png como entrada, resultando encontrado foi o da sa√≠da abaixo:


.Figura 4: trocaregioes.png
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/trocaregioes.png]
image::exercicio_2/trocaregioes.png[]


=== Cap√≠tulo 5, Serializa√ß√£o de dados em ponto flutuante via FileStorage

Nesse cap√≠tulo foi instru√≠do na atividade √† se fazer uma imagem de 256x256 pixels de uma sen√≥ide com 4 per√≠odos e amplitude de 127, e gerar um .png e um .yml dessa sen√≥ide criada.

Sen√≥ide do exerc√≠cio, com 8 per√≠odos:

.Figura 5: Sen√≥ide de 8 per√≠odos
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_5/8-senoide-256.png]
image::exercicio_5/8-senoide-256.png[]

Arquivo YML: https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_5/8-senoide-256.yml[8-senoide-256.yml]

O resultado gerado pelo programa para a sen√≥ide de 4 per√≠odos foi a seguinte:

.Figura 6: Sen√≥ide de 4 per√≠odos
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_5/4-senoide-256.png]
image::exercicio_5/4-senoide-256.png[]

Arquivo YML gerado: https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_5/4-senoide-256.yml[4-senoide-256.yml]

A outra parte do exerc√≠cio pedia para tra√ßar um gr√°fico da diferen√ßa calculada ao londo de uma linha extra√≠da das imagens correspondentes.
O gr√°fico extra√≠do foi esse:

.Figura 7: Diferen√ßa entre sen√≥ides
image::exercicio_5/diferenca.png[]

Pode-se notar na imagem que anova onda formada pela sobreposi√ß√£o das sen√≥ides das imagens anteriores tamb√©m √© peri√≥dica, mas com um padr√£o muito mais complexo do que as suas geradoras, isso acontece porque as ondas que a formaram se misturam e se interferem, o que acaba gerando essa nova estrutura oscilat√≥ria.

=== Cap√≠tulo 10, Decomposi√ß√£o de imagens em planos de bits

Essa atividade consiste em usar o c√≥digo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_10/bitplanes.cpp[bitplanes.cpp] como base e criar um que possa recuperar uma imagem codificada escondida dentro de outra, em um processo chamado de esteganografia.

Foi criado ent√£o o c√≥digo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_10/recover.cpp[recover.cpp] com esse intuito, e utilizado na imagem √† seguir:

.Figura 8: Imagem codificada
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_10/esteganografia.png]
image::exercicio_10/esteganografia.png[]



O resultado que saiu ap√≥s o c√≥digo ser rodado foi a seguinte imagem:

.Figura 9: Imagem recuperada
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_10/imagem_recuperada.png]
image::exercicio_10/imagem_recuperada.png[]

=== Cap√≠tulo 11, Preenchendo regi√µes
Nessa situa√ß√£o do c√≥digo de https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_11/labeling.cpp[labeling.cpp] somente 255 objetos poderem ser verificados, isso acontece por causa do tipo de dados (uchar) que √© utilizado, pois como esse tipo possui 8 bits, o m√°ximo de tons que se pode utilizar √© de 2^8^, e caso seja necess√°rio contar mais do que 255 objetos, o c√≥digo iria acabar voltando ao tom 0, para que isso seja poss√≠vel, √© necess√°rio uma mudan√ßa de tipo para um dado que tenha mais capacidade de armazenamento, como por exemplo, usar CV_16U que suporta 16bits, assim poderia contar at√© 2^16^ objetos na figura.

A altera√ß√£o seria abaixo da linha 21 do programa https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_11/labeling.cpp[labeling.cpp], que √© onde seria adicionado as linhas de c√≥digo abaixo para se criar a iamgem com 16 bits para armazenar os r√≥tulos, ao final, antes dos comandos de *imshow*, faz-se uma convers√£o de volta para 8 bits para poder normalizar a imagem e mostr√°-la em tela novamente.

[source,cpp]
----
21
    *labelImage = cv::Mat::zeros(height, width, CV_16U);*
22    
    [. . .]
30  if (image.at<uchar>(i, j) == 255 *&& labelImage.at<ushort>(i, j) == 0*) {
31      // achou um objeto
32      nobjects++;
33      // para o floodfill as coordenadas
34      // x e y s√£o trocadas.
35      p.x = j;
36      p.y = i;
37      // preenche o objeto com o contador
38      cv::floodFill(*labelImage*, p, nobjects);
    
    [. . .]
42  std::cout << "a figura tem " << nobjects << " bolhas\n";
    *cv::Mat displayImage;*
    *labelImage.convertTo(displayImage, CV_8U, 255.0 / nobjects);*
----

Entre "*" est√£o as partes adicionadas ao c√≥digo de labeling.cpp para poder marcar mais de 255 objetos em cena.

Para a segunda parte do exerc√≠cio, onde devemos aprimorar o c√≥digo de https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_11/labeling.cpp[labeling.cpp] para que seja poss√≠vel identificar regi√µes com ou sem buracos internos, foi feito o seguinte arquivo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_11/newlabeling.cpp[newlabeling.cpp], onde foi assumido que n√£o se deve contar as bolhas nas bordas da imagem.

Aqui abaixo podemos observar alguns passos do processo de FloodFill:  +
1. A imagem bolhas.png de entrada  +
2. Ap√≥s excluir as bolhas que tocam as bordas do processo  +
3. Ap√≥s finalizar o processo de labeling  +
4. A contagem do total de bolhas  +

.Figura 10: Bolhas
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_11/bolhas.png]
image::exercicio_11/bolhas.png[]


.Figura 11: Bolhas 2
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_11/bolhas2.png]
image::exercicio_11/bolhas2.png[]

.Figura 12: Bolhas 3
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_11/bolhas3.png]
image::exercicio_11/bolhas3.png[]

.Figura 13: Contagem de bolhas
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_11/status.png]
image::exercicio_11/status.png[]


=== Cap√≠tulo 12, Manipula√ß√£o de histogramas

Para este exerc√≠cio, foi proposto que fiz√©ssemos um c√≥digo tendo o https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_12/histogram.cpp[histogram.cpp] como base para equalizar o histograma de uma imagem gerada por uma c√¢mera.
Nesse caso, foi utilizado o programa DroidCAM em conjunto com um celular Samsung M53 5G para conseguir obter os resultados em v√≠deo e capturas de tela do histograma, o c√≥digo que foi utilizado √© o https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_12/equalize.cpp[equalize.cpp], e os resultados obtidos foram as imagens a seguir:

.Figura 14: Dedo em frente √† c√¢mera
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_12/dedo .png]
image::exercicio_12/dedo.png[]

.Figura 15: Polvo Rosa
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_12/polvo_rosa.png]
image::exercicio_12/polvo_rosa.png[]

.Figura 16: Polvo Verde
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_12/polvo_verde.png]
image::exercicio_12/polvo_verde.png[]

.Figura 17: Tent√°culo rosa sobre a c√¢mera
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_12/rosa.png]
image::exercicio_12/rosa.png[]

.Figura 18: Tent√°culo verde sobre a c√¢mera
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_12/verde.png]
image::exercicio_12/verde.png[]


=== Cap√≠tulo 14, Filtragem no dom√≠nio espacial I - Convolu√ß√£o

Neste exerc√≠cio √© proposto que seja feito filtros de m√©dia com tamanhos de m√°scaras de 11x11 e 21x21, fa√ßa uma captura de imagem e compare ambos os filtros com o filtro de m√©dia com m√°scara de tamanho 3x3.

O c√≥digo utlilizado se encontra neste arquivo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_14/convolucao.cpp[convolucao.cpp]

Ap√≥s ser feito a captura com a mesma imagem, as sa√≠das dos filtros fpra as seguintes:

.Figura 19: Sa√≠da de filtro com m√°scara tamanho 3x3
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_14/Filtro3x3.png]
image::exercicio_14/Filtro3x3.png[]

.Figura 20: Sa√≠da de filtro com m√°scara tamanho 11x11
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_14/Filtro11x11.png]
image::exercicio_14/Filtro11x11.png[]


.Figura 21: Sa√≠da de filtro com m√°scara tamanho 21x21
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_14/Filtro21x21.png]
image::exercicio_14/Filtro21x21.png[]

=== Cap√≠tulo 15, Filtragem no dom√≠nio espacial II - TiltShift

== Lista 2

=== Cap√≠tulo 16, A Tranformada Discreta de Fourier

Para o exerc√≠cio deste cap√≠tulo, √© pedido que seja calculado o espectro de magnetude de uma imagem de sen√≥ide de 256x256 pixels usando o c√≥digo do arquivo de https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_16/dft.cpp[dft.cpp] , e compar√°-lo com um c√≥digo adaptado com base no https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_5/filestorage.cpp[filestorage.cpp] onde esse c√≥digo ter√° como entrada um c√≥digo em YAML equivalente √† imagem de entrada do arquivo dft.cpp.

O c√≥digo feito foi o https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_16/dft_2.cpp[dft_2.cpp] , onde a entrada foi a mesma imagem de 256x256 pixels, por√©m o arquivo ".yml" da mesma, gerado com o filestorage.cpp anteriormente.

.Figura 22: Imagem de entrada
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_16/figura.png]
image::exercicio_16/Figura.png[]

As sa√≠das que consegui foram as seguintes:

.Figura 23: Sa√≠da direto da imagem
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_16/espectros.png]
image::exercicio_16/Espectros.png[]

.Figura 24: Sa√≠da do c√≥digo YAML da imagem
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_16/espectros_2.png]
image::exercicio_16/Espectros_2.png[]

Pode n√£o parecer nada diferente, mas a segunda imagem se aproxima mais da sen√≥ide original pelo fato de ela ser uma representa√ß√£o feita diretamente dos valores obtidos ao inv√©s de serem obtidos ap√≥s uma convers√£o para imagem como a primeira.

=== Cap√≠tulo 17. Filtragem no Dom√≠nio da Frequ√™ncia

Nesse cap√≠tulo √© proposto que peguemos o c√≥digo da https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_17/dftfilter.cpp[dftfilter.cpp] e modifiquemos para poder corrigir ilumina√ß√µes em cenas com o filtro homom√≥rfico.

Com as mudan√ßas feitas, foi obtido o seguinte c√≥digo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_17/homomorfico.cpp[homomorfico.cpp] , onde, ao ser rodado com a imagem, mostrar√° uma barra para poder ajustar a ilumina√ß√£o da imagem como mostra no exemplo com as fotos do Biel √† seguir.


.Figura 25: Filtro homom√≥rfico autom√°tico antes de ser implementado o slider para ajustes manuais
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_17/homomorfico.png]
image::exercicio_17/homomorfico.png[]

.Figura 26: Imagem original
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_17/biel.png]
image::exercicio_17/biel.png[]

.Figura 27: Filtro com 14 selecionado na barra
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_17/Filtro-14.png]
image::exercicio_17/Filtro-14.png[]

.Figura 28: Filtro com 50 selecionado na barra
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_17/Filtro-50.png]
image::exercicio_17/Filtro-50.png[]

.Figura 29: Filtro com 100 selecionado na barra
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_17/Filtro-100.png]
image::exercicio_17/Filtro-100.png[]

=== Cap√≠tulo 20. Quantiza√ß√£o vetorial com k-means

No cap√≠tulo em quest√£o, a atividade a ser desenvolvida era a de usar o https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_20/kmeans.cpp[kmeans.cpp] como base para desenvolver um outro que execute com o par√¢metro de nRodadas = 1, gerando 10 rodadas diferentes de algoritmos, e a cada rodada, gerando centros aleat√≥rios para o algoritmo iniciar.
Foram realizadas as mudan√ßas e o algoritmo final foi o https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_20/kmeans_random.cpp[kmeans_random.cpp] , e ao final das 10 rodadas com a imagem do https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_20/biel.png[Biel.png] , os resultados foram as seguintes sa√≠das:

[cols="a,a,a", frame=none, grid=none, align=center]
|===
|image::exercicio_20/saida1.jpg[] 
+++Sa√≠da 1+++
|image::exercicio_20/saida2.jpg[] 
+++Sa√≠da 2+++
|image::exercicio_20/saida3.jpg[] 
+++Sa√≠da 3+++
|image::exercicio_20/saida4.jpg[] 
+++Sa√≠da 4+++
|image::exercicio_20/saida5.jpg[] 
+++Sa√≠da 5+++
|image::exercicio_20/saida6.jpg[] 
+++Sa√≠da 6+++
|image::exercicio_20/saida7.jpg[] 
+++Sa√≠da 7+++
|image::exercicio_20/saida8.jpg[] 
+++Sa√≠da 8+++
|image::exercicio_20/saida9.jpg[] 
+++Sa√≠da 9+++
|image::exercicio_20/saida10.jpg[] 
+++Sa√≠da 10+++
|
|
|===

As sa√≠das est√£o diferentes exatamente por causa dos centros escolhidos aleatoriamente no in√≠cio.

== Lista 3

=== Cap√≠tulo 21. Extra√ß√£o de contornos

Neste cap√≠tulo, o exerc√≠cio √© dividido em 2 partes, a primeira pede para aplicar o c√≥digo original do https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_21/contornos.cpp[contornos.cpp] na imagem dos ret√¢ngulos e ver quantos pontos s√£o gerados para o seu contorno.

O resultado foi o seguinte:

.Figura 30: Pontos de contorno extra√≠dos
[link=https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_21/contornos_original.png]
image::exercicio_21/contornos_original.png[]

Ap√≥s isso, a atividade pediu para modificar o programa e extrair os contornos novamente, ao final o c√≥digo finalizado ficou neste arquivo https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_21/contornos2.cpp[contornos2.cpp] e a sa√≠da foi a seguinte:

.Figura 31: Pontos de contorno simplificados extra√≠dos
[link=https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_21/cont_retangulos.png]
image::exercicio_21/cont_retangulos.png[]

Como podemos notar, o n√∫mero de pontos encontrados caiu de 746 para 10, ou seja, as modifica√ß√µes pedidas no c√≥digo fizeram que pontos redundantes fossem ignorados na hora de contar os pontos do contorno.

OBS: O resultado IDEAL seriam 8 pontos, mas √© poss√≠vel que tenham sido contados 2 pontos em cada aresta interna, pois √© onde ficam as interse√ß√µes dos quadrados.

=== Cap√≠tulo 22. Extra√ß√£o de caracter√≠sticas: Momentos de Hu para regi√µes

Esse exerc√≠cio foi um pouco complicado de se resolver, pois ele pedia para procurar por uma pessoa no meio da multid√£o, o c√≥digo feito para isso foi o 

https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_22/momentos-regioes-2.cpp[momento-regioes-2.cpp] , que rodou com as seguintes imagens para procurar.

.Figura 32: Pessoa.jpg
[link=https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_22/pessoa.jpg]
image::exercicio_22/pessoa.jpg[]

.Figura 33: Multidao.jpg
[link=https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_22/multidao.jpg]
image::exercicio_22/multidao.jpg[]


O resultado depois de fazer a varredura foi o seguinte:


.Figura 34: Resultado.png
[link=https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_22/resultado.png]
image::exercicio_22/resultado.png[]


.Figura 35: Localiza√ß√£o.png
[link=https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_22/localizacao.png]
image::exercicio_22/localizacao.png[]


Como pode ser notado nessa √∫ltima imagem, o resultado foi que o algoritmo encontrou a pessoa procurada no ponto [2129, 495] no meio da multid√£o.

=== Cap√≠tulo 23. Extra√ß√£o de caracter√≠sticas: Momentos de Hu para contornos 

Agora nesse cap√≠tulo, foi pedido para modificar o c√≥digo, o que gerou o arquivo https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_23/momentos.cpp[momentos.cpp] ap√≥s as altera√ß√µes, e com essas mudan√ßas, foi pedido para se obter um arquivo com n√∫meros, que eles, por sua vez, s√£o valores equivalentes aos momentos de Hu para os contornos de figuras que est√£o dispon√≠veis na imagem que foi processada pelo c√≥digo.


.Figura 36: Imagem original.png
[link=https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_23/momentos.png]
image::exercicio_23/momentos.png[]


.Figura 37: Imagem processada.png
[link=https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_23/contornos-rotulados.png]
image::exercicio_23/contornos-rotulados.png[]

.Momentos de Hu dos contornos das figuras
|===
|N| ùúÇ~1~| ùúÇ~2~| ùúÇ~3~| ùúÇ~4~| ùúÇ~5~| ùúÇ~6~| ùúÇ~7~
|3| 0.798046| 5.00282| 8.66349| 12.1468| -22.5546| 14.9779| -23.5111
|5| 0.798076| 5.19683| 6.91077| 11.4442| -20.9916| -14.3809| -20.6653
|7| -0.0869539| -0.157887| 1.49555| 1.6833| 3.27273| 1.60454| -5.49111
|8| -0.120131| -0.228636| 1.25615| 1.35104| 2.65464| 1.23696| 4.88526
|9| 0.373823| 0.820174| 4.12233| 4.44221| 8.73046| 4.89129| 9.50767
|10| 0.371474| 0.82325| 3.12096| 3.355| 6.59299| 3.76676| -8.87464
|11| -0.129544| -0.243706| 1.00717| 1.13737| 2.20964| 1.01563| 4.50646
|12| 0.798008| 4.86567| 7.60833| 11.6456| -21.5786| -15.5273| -21.3335
|13| 0.334708| 0.736686| 2.78304| 2.96471| 5.83859| 3.33305| 8.44577
|14| -0.106722| -0.196061| 1.05617| 1.19955| 2.32742| 1.10162| -4.48549
|15| -0.0958813| -0.172621| 0.989909| 1.13171| 2.19255| 1.04588| 4.11805
|16| -0.032083| -0.0450323| 1.34178| 1.48339| 2.89599| 1.46109| -5.03442
|17| 0.798052| 5.09326| 7.97304| 13.5646| -24.3674| -16.275| 24.753
|18| -0.107708| -0.200982| 1.37277| 1.5268| 2.9766| 1.4266| -4.96253
|19| 0.798084| 5.30554| 6.73545| 11.1048| 20.1286| 13.9228| -20.2353
|20| 0.340446| 0.748341| 2.87315| 3.05754| 6.02289| 3.43174| -9.06747
|21| -0.11084| -0.204674| 1.06291| 1.20705| 2.34204| 1.10472| 5.49108
|24| -0.0581881| -0.095187| 1.47008| 1.70388| 3.29087| 1.65632| -5.51248
|25| 0.798063| 5.11058| 8.00379| 12.475| -23.804| 15.8112| -22.7158
|26| 0.369687| 0.816975| 3.27876| 3.50028| 6.89012| 3.91147| -8.30278
|27| -0.00117395| 0.019307| 1.50242| 1.67226| 3.2596| 1.68191| 6.34849
|28| 0.362363| 0.792965| 3.99692| 4.2232| 8.3335| 4.62146| 9.8081
|29| 0.338675| 0.738061| 3.85143| 4.03897| 7.98444| 4.4133| -9.42881
|===

Com esses valores encontrados pelos momentos de Hu, podemos observar que figuras semelhantes v√£o ter valores semelhantes, como por exemplo, as figuras de n√∫mero 3, 5 e 12 (entre outras), que s√£o arruelas circulares, e claro que, mesmo que sejam semelhantes, se forem contornos parecidos, mas que est√£o rotacionados, podem haver diverg√™ncias, como no caso do momento ùúÇ~7~ das figuras 10 e 13, que est√£o basicamente apontando para sentidos opostos.

=== Cap√≠tulo 24. Filtragem de forma com morfologia matem√°tica

Nesse √∫ltimo exerc√≠cio foi pedido para que se possa fazer os d√≠gitos de 7 segmentos virarem um n√∫mero que possa ser processado por um leitor digital, e para isso, √© necess√°rio juntar os 7 segmentos e, por poder ser um n√∫mero decimal, devemos manter o ponto que separa a parte inteira da parte fracionada separado.
As imagens com n√∫meros de entradas foram as seguintes:

[cols="a,a,a", frame=none, grid=none, align=center]
|===
|image::exercicio_24/digitos-1.png[] 
+++D√≠gito 1+++
|image::exercicio_24/digitos-2.png[] 
+++D√≠gito 2+++
|image::exercicio_24/digitos-3.png[] 
+++D√≠gito 3+++
|image::exercicio_24/digitos-4.png[] 
+++D√≠gito 4+++
|image::exercicio_24/digitos-5.png[] 
+++D√≠gito 5+++
|image::exercicio_24/digitos-6.png[] 
+++D√≠gito 6+++
|===

Ap√≥s passarem pelo c√≥digo https://github.com/IgorCirne/IgorCirne.github.io/blob/main/exercicio_24/morfologia2.cpp[morfologia2.cpp] , as sa√≠das foram o seguinte:

[cols="a,a,a", frame=none, grid=none, align=center]
|===
|image::exercicio_24/digito-1-resultado.png[] 
+++D√≠gito 1+++
|image::exercicio_24/digito-2-resultado.png[] 
+++D√≠gito 2+++
|image::exercicio_24/digito-3-resultado.png[] 
+++D√≠gito 3+++
|image::exercicio_24/digito-4-resultado.png[] 
+++D√≠gito 4+++
|image::exercicio_24/digito-5-resultado.png[] 
+++D√≠gito 5+++
|image::exercicio_24/digito-6-resultado.png[] 
+++D√≠gito 6+++
|===

O que foi uma sa√≠da aceit√°vel para o leitor poder decifrar qual n√∫mero est√° sendo mostrado no leitor de 7 d√≠gitos.
