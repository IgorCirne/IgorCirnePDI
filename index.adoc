:toc: left
:toclevels: 2
:toc-title: Sum√°rio
:!figure-caption:

= Processamento Digital de Imagens
Igor Cirne Borges de Oliveira

:icons: font
:summary:

toc::[]

== Introdu√ß√£o

Esta p√°gina re√∫ne os projetos e atividades desenvolvidos na disciplina de Processamento Digital de Imagens (PDI), organizados em formato AsciiDoc e hospedados no GitHub Pages.

== Lista 1

=== Cap√≠tulo 2. Manipula√ß√£o de pixels em imagens

Com base no programa https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/pixels.cpp[pixels.cpp], foi desenvolvido o c√≥digo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/regions.cpp[regions.cpp], que recebe como entrada dois pontos P1 e P2 (coordenadas x e y) e aplica o efeito de negativo √† regi√£o compreendida entre eles.

Imagem de entrada:

.Figura 1: biel.png
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/biel.png]
image::exercicio_2/biel.png[]

Ap√≥s compilar o c√≥digo com o arquivo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/CMakeLists.txt[CMakeLists.txt], os seguintes resultados foram obtidos:

*P1 = [100, 50], P2 = [200, 200]*

.Figura 2: biel-2.png
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/biel-2.png]
image::exercicio_2/biel-2.png[]

*P1 = [50, 50], P2 = [100, 150]*

.Figura 3: biel-3.png
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/biel-3.png]
image::exercicio_2/biel-3.png[]

Na segunda parte do exerc√≠cio, que envolvia a troca de regi√µes, foi criado o programa https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/trocaregioes.cpp[trocaregioes.cpp], utilizando um novo arquivo de build: https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/CMakeLists2.txt[CMakeLists.txt].

Resultado:

.Figura 4: trocaregioes.png
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_2/trocaregioes.png]
image::exercicio_2/trocaregioes.png[]

=== Cap√≠tulo 5. Serializa√ß√£o de dados com FileStorage

Nesta atividade, foi solicitado gerar uma imagem senoidal de 256x256 pixels com 4 per√≠odos e amplitude 127, salvando-a em formato `.png` e `.yml`.

Exemplo de sen√≥ide com 8 per√≠odos:

.Figura 5
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_5/8-senoide-256.png]
image::exercicio_5/8-senoide-256.png[]

Arquivo YML: https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_5/8-senoide-256.yml

Resultado com 4 per√≠odos:

.Figura 6
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_5/4-senoide-256.png]
image::exercicio_5/4-senoide-256.png[]

Arquivo YML: https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_5/4-senoide-256.yml

Em seguida, foi tra√ßado um gr√°fico da diferen√ßa entre uma linha extra√≠da dessas imagens:

.Figura 7: Diferen√ßa entre sen√≥ides
image::exercicio_5/diferenca.png[]

Nota-se que a sobreposi√ß√£o das ondas originais resulta em uma nova forma de onda peri√≥dica, por√©m mais complexa, devido √† interfer√™ncia entre elas.


=== Cap√≠tulo 10. Decomposi√ß√£o de imagens em planos de bits

Esta atividade explora a esteganografia, onde uma imagem √© codificada discretamente dentro de outra. O c√≥digo base utilizado foi https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_10/bitplanes.cpp[bitplanes.cpp], e o programa criado para recuperar a imagem oculta foi o https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_10/recover.cpp[recover.cpp].

Imagem de entrada:

.Figura 8: Imagem com informa√ß√£o oculta
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_10/esteganografia.png]
image::exercicio_10/esteganografia.png[]

Imagem recuperada:

.Figura 9: Resultado da decodifica√ß√£o
[link=https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_10/imagem_recuperada.png]
image::exercicio_10/imagem_recuperada.png[]

=== Cap√≠tulo 11. Rotulagem de regi√µes

O c√≥digo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_11/labeling.cpp[labeling.cpp] rotula regi√µes conectadas em uma imagem. No entanto, por utilizar o tipo `uchar` (8 bits), apenas 255 objetos distintos podem ser representados. Para permitir contagem al√©m desse limite, √© necess√°rio alterar o tipo de `CV_8U` para `CV_16U`.

Modifica√ß√£o sugerida abaixo da linha 21:

[source,cpp]
----
21  labelImage = cv::Mat::zeros(height, width, CV_16U);
...
30  if (image.at<uchar>(i, j) == 255 && labelImage.at<ushort>(i, j) == 0) {
    // in√≠cio do flood fill
...
42  std::cout << "A figura tem " << nobjects << " bolhas\n";
    cv::Mat displayImage;
    labelImage.convertTo(displayImage, CV_8U, 255.0 / nobjects);
----

Para a segunda parte do exerc√≠cio, que envolve identificar bolhas com ou sem buracos internos (excluindo bordas), foi desenvolvido o c√≥digo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_11/newlabeling.cpp[newlabeling.cpp].

Evolu√ß√£o do processo:

.Figura 10: Imagem original
image::exercicio_11/bolhas.png[]

.Figura 11: Ap√≥s remo√ß√£o das bolhas da borda
image::exercicio_11/bolhas2.png[]

.Figura 12: Ap√≥s rotulagem completa
image::exercicio_11/bolhas3.png[]

.Figura 13: Contagem final de bolhas
image::exercicio_11/status.png[]

=== Cap√≠tulo 12. Equaliza√ß√£o de histograma

Com base no c√≥digo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_12/histogram.cpp[histogram.cpp], foi desenvolvido o programa https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_12/equalize.cpp[equalize.cpp] para realizar a equaliza√ß√£o do histograma de imagens capturadas com o aplicativo DroidCam.

Imagens de entrada e resultado:

.Figura 14: Dedo na c√¢mera
image::exercicio_12/dedo.png[]

.Figura 15: Polvo rosa
image::exercicio_12/polvo_rosa.png[]

.Figura 16: Polvo verde
image::exercicio_12/polvo_verde.png[]

.Figura 17: Tent√°culo rosa
image::exercicio_12/rosa.png[]

.Figura 18: Tent√°culo verde
image::exercicio_12/verde.png[]

=== Cap√≠tulo 14. Filtragem no dom√≠nio espacial I ‚Äì Convolu√ß√£o

O exerc√≠cio prop√µe a aplica√ß√£o de filtros de m√©dia com m√°scaras de diferentes tamanhos (3x3, 11x11 e 21x21). O c√≥digo est√° dispon√≠vel em: https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_14/convolucao.cpp[convolucao.cpp].

Resultados:

.Figura 19: Filtro 3x3
image::exercicio_14/Filtro3x3.png[]

.Figura 20: Filtro 11x11
image::exercicio_14/Filtro11x11.png[]

.Figura 21: Filtro 21x21
image::exercicio_14/Filtro21x21.png[]

=== Cap√≠tulo 15. Filtragem no dom√≠nio espacial II ‚Äì Tilt-Shift

*(Este cap√≠tulo ainda n√£o possui conte√∫do registrado.)*

== Lista 2

=== Cap√≠tulo 16. Transformada Discreta de Fourier

Com o c√≥digo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_16/dft.cpp[dft.cpp], foi calculado o espectro de magnitude de uma imagem senoidal. Em seguida, um c√≥digo alternativo foi feito para ler a imagem diretamente de um arquivo `.yml`, dispon√≠vel em: https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_16/dft_2.cpp[dft_2.cpp].

.Figura 22: Imagem de entrada
image::exercicio_16/Figura.png[]

.Figura 23: Espectro via imagem
image::exercicio_16/Espectros.png[]

.Figura 24: Espectro via YAML
image::exercicio_16/Espectros_2.png[]

A segunda imagem apresenta melhor fidelidade √† sen√≥ide original, pois os valores s√£o lidos diretamente do arquivo de dados.

=== Cap√≠tulo 17. Filtragem no dom√≠nio da frequ√™ncia ‚Äì Filtro homom√≥rfico

Foi proposto modificar o c√≥digo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_17/dftfilter.cpp[dftfilter.cpp] para aplicar corre√ß√£o de ilumina√ß√£o com filtro homom√≥rfico. O c√≥digo final est√° dispon√≠vel em: https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_17/homomorfico.cpp[homomorfico.cpp].

Exemplos de resultado com ajustes na barra deslizante:

.Figura 25: Resultado autom√°tico
image::exercicio_17/homomorfico.png[]

.Figura 26: Imagem original
image::exercicio_17/biel.png[]

.Figura 27: Filtro com valor 14
image::exercicio_17/Filtro-14.png[]

.Figura 28: Filtro com valor 50
image::exercicio_17/Filtro-50.png[]

.Figura 29: Filtro com valor 100
image::exercicio_17/Filtro-100.png[]

=== Cap√≠tulo 20. Quantiza√ß√£o vetorial com k-means

A atividade consistia em realizar 10 execu√ß√µes do algoritmo k-means com diferentes centros iniciais, baseado no c√≥digo https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_20/kmeans.cpp[kmeans.cpp]. O c√≥digo final com aleatoriedade est√° em: https://github.com/IgorCirne/IgorCirnePDI/tree/main/exercicio_20/kmeans_random.cpp[kmeans_random.cpp].

Resultados:

[cols="a,a,a", frame=none, grid=none, align=center]
|===
|image::exercicio_20/saida1.jpg[] 
+++Sa√≠da 1+++
|image::exercicio_20/saida2.jpg[] 
+++Sa√≠da 2+++
|image::exercicio_20/saida3.jpg[] 
+++Sa√≠da 3+++
|image::exercicio_20/saida4.jpg[] 
+++Sa√≠da 4+++
|image::exercicio_20/saida5.jpg[] 
+++Sa√≠da 5+++
|image::exercicio_20/saida6.jpg[] 
+++Sa√≠da 6+++
|image::exercicio_20/saida7.jpg[] 
+++Sa√≠da 7+++
|image::exercicio_20/saida8.jpg[] 
+++Sa√≠da 8+++
|image::exercicio_20/saida9.jpg[] 
+++Sa√≠da 9+++
|image::exercicio_20/saida10.jpg[] 
+++Sa√≠da 10+++
|===

== Lista 3

=== Cap√≠tulo 21. Extra√ß√£o de contornos

Este exerc√≠cio foi dividido em duas partes. A primeira consistia em aplicar o c√≥digo https://github.com/IgorCirne/IgorCirnePDI/blob/main/exercicio_21/contornos.cpp[contornos.cpp] √† imagem dos ret√¢ngulos e verificar o n√∫mero de pontos extra√≠dos do contorno.

Resultado da primeira execu√ß√£o:

.Figura 30: Contorno original com 746 pontos
image::exercicio_21/contornos_original.png[]

Na segunda parte, o programa foi modificado para reduzir os pontos de contorno, gerando o arquivo https://github.com/IgorCirne/IgorCirnePDI/blob/main/exercicio_21/contornos2.cpp[contornos2.cpp].

Resultado:

.Figura 31: Contorno simplificado com 10 pontos
image::exercicio_21/cont_retangulos.png[]

Nota: O resultado ideal seria 8 pontos, mas √© poss√≠vel que alguns cantos tenham sido contados duas vezes devido √† interse√ß√£o dos ret√¢ngulos.

=== Cap√≠tulo 22. Extra√ß√£o de caracter√≠sticas ‚Äì Momentos de Hu (regi√µes)

Neste exerc√≠cio, o objetivo era identificar uma pessoa no meio de uma multid√£o utilizando momentos de Hu.

O c√≥digo implementado est√° dispon√≠vel em: https://github.com/IgorCirne/IgorCirnePDI/blob/main/exercicio_22/momentos-regioes-2.cpp[momento-regioes-2.cpp].

Imagens utilizadas:

.Figura 32: Pessoa isolada
image::exercicio_22/pessoa.jpg[]

.Figura 33: Imagem da multid√£o
image::exercicio_22/multidao.jpg[]

Resultado obtido ap√≥s an√°lise por varredura:

.Figura 34: Coordenada encontrada: [2129, 495]
image::exercicio_22/localizacao.png[]

=== Cap√≠tulo 23. Extra√ß√£o de caracter√≠sticas ‚Äì Momentos de Hu (contornos)

A proposta era modificar o c√≥digo para extrair os momentos de Hu de contornos rotulados de uma imagem. O resultado foi implementado no arquivo https://github.com/IgorCirne/IgorCirnePDI/blob/main/exercicio_23/momentos.cpp[momentos.cpp].

Imagens envolvidas:

.Figura 35: Imagem original
image::exercicio_23/momentos.png[]

.Figura 36: Contornos rotulados
image::exercicio_23/contornos-rotulados.png[]

.Momentos de Hu para contornos identificados
|===
|N |ùúÇ~1~|ùúÇ~2~|ùúÇ~3~|ùúÇ~4~|ùúÇ~5~|ùúÇ~6~|ùúÇ~7~
|3| 0.798046| 5.00282| 8.66349| 12.1468| -22.5546| 14.9779| -23.5111
|5| 0.798076| 5.19683| 6.91077| 11.4442| -20.9916| -14.3809| -20.6653
|7| -0.0869539| -0.157887| 1.49555| 1.6833| 3.27273| 1.60454| -5.49111
|8| -0.120131| -0.228636| 1.25615| 1.35104| 2.65464| 1.23696| 4.88526
|9| 0.373823| 0.820174| 4.12233| 4.44221| 8.73046| 4.89129| 9.50767
|10| 0.371474| 0.82325| 3.12096| 3.355| 6.59299| 3.76676| -8.87464
|11| -0.129544| -0.243706| 1.00717| 1.13737| 2.20964| 1.01563| 4.50646
|12| 0.798008| 4.86567| 7.60833| 11.6456| -21.5786| -15.5273| -21.3335
|13| 0.334708| 0.736686| 2.78304| 2.96471| 5.83859| 3.33305| 8.44577
|14| -0.106722| -0.196061| 1.05617| 1.19955| 2.32742| 1.10162| -4.48549
|15| -0.0958813| -0.172621| 0.989909| 1.13171| 2.19255| 1.04588| 4.11805
|16| -0.032083| -0.0450323| 1.34178| 1.48339| 2.89599| 1.46109| -5.03442
|17| 0.798052| 5.09326| 7.97304| 13.5646| -24.3674| -16.275| 24.753
|18| -0.107708| -0.200982| 1.37277| 1.5268| 2.9766| 1.4266| -4.96253
|19| 0.798084| 5.30554| 6.73545| 11.1048| 20.1286| 13.9228| -20.2353
|20| 0.340446| 0.748341| 2.87315| 3.05754| 6.02289| 3.43174| -9.06747
|21| -0.11084| -0.204674| 1.06291| 1.20705| 2.34204| 1.10472| 5.49108
|24| -0.0581881| -0.095187| 1.47008| 1.70388| 3.29087| 1.65632| -5.51248
|25| 0.798063| 5.11058| 8.00379| 12.475| -23.804| 15.8112| -22.7158
|26| 0.369687| 0.816975| 3.27876| 3.50028| 6.89012| 3.91147| -8.30278
|27| -0.00117395| 0.019307| 1.50242| 1.67226| 3.2596| 1.68191| 6.34849
|28| 0.362363| 0.792965| 3.99692| 4.2232| 8.3335| 4.62146| 9.8081
|29| 0.338675| 0.738061| 3.85143| 4.03897| 7.98444| 4.4133| -9.42881
|===

Com esses dados, √© poss√≠vel notar que figuras semelhantes (como as arruelas circulares) compartilham valores de momentos semelhantes, ainda que pequenas varia√ß√µes possam surgir por rota√ß√£o ou leve distor√ß√£o.

=== Cap√≠tulo 24. Filtragem de forma com morfologia matem√°tica

Neste exerc√≠cio final, o objetivo era transformar d√≠gitos de 7 segmentos em n√∫meros leg√≠veis por um sistema digital. √â importante preservar o ponto decimal separadamente para manter a estrutura num√©rica.

Imagens de entrada:

[cols="a,a,a", frame=none, grid=none, align=center]
|===
|image::exercicio_24/digitos-1.png[] 
+++D√≠gito 1+++
|image::exercicio_24/digitos-2.png[] 
+++D√≠gito 2+++
|image::exercicio_24/digitos-3.png[] 
+++D√≠gito 3+++
|image::exercicio_24/digitos-4.png[] 
+++D√≠gito 4+++
|image::exercicio_24/digitos-5.png[] 
+++D√≠gito 5+++
|image::exercicio_24/digitos-6.png[] 
+++D√≠gito 6+++
|===

Ap√≥s o processamento com o c√≥digo https://github.com/IgorCirne/IgorCirnePDI/blob/main/exercicio_24/morfologia2.cpp[morfologia2.cpp], os resultados foram os seguintes:

[cols="a,a,a", frame=none, grid=none, align=center]
|===
|image::exercicio_24/digito-1-resultado.png[] 
+++Resultado 1+++
|image::exercicio_24/digito-2-resultado.png[] 
+++Resultado 2+++
|image::exercicio_24/digito-3-resultado.png[] 
+++Resultado 3+++
|image::exercicio_24/digito-4-resultado.png[] 
+++Resultado 4+++
|image::exercicio_24/digito-5-resultado.png[] 
+++Resultado 5+++
|image::exercicio_24/digito-6-resultado.png[] 
+++Resultado 6+++
|===

O resultado final foi satisfat√≥rio, com os n√∫meros bem definidos para futura interpreta√ß√£o por um leitor automatizado.
